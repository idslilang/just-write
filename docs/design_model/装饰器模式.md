### 结构型模式之装饰器模式

#### 1. 定义

指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。

#### 2. 应用场景

- 当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。
- 当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰器模式却很好实现。
- 当对象的功能要求可以动态地添加，也可以再动态地撤销时。

#### 3. 代码实现

代码实现比较简单，不如说对项目中的已经实现的一个自行车实现类进行装饰

定义抽象自行车：

```
public interface Bike {

    public void  drive();

}
```

定义抽象自行车实现类：

```
public class SDBike implements Bike {
    public void drive() {
        System.out.println("我正在直线行驶");
    }
}
```

定义自行车实现类装饰器：

```
public class SDBikeDecorator implements Bike {


    private SDBike sdBike;

    public SDBikeDecorator(SDBike sdBike) {
        this.sdBike = sdBike;
    }


    public void drive() {
        System.out.println("我正在放着音乐");
        sdBike.drive();
        System.out.println("我正在载着朋友");
    }
}
```

定义测试类：

```
public class Test {

    public static void main(String[] args) {
        SDBikeDecorator decorator = new SDBikeDecorator(new SDBike());

        decorator.drive();
    }
}
```

输出结果：

```
我正在放着音乐
我正在直线行驶
我正在载着朋友
```



#### 4. 装饰器模式和代理模式的区别

- 代理是全权代理，目标根本不对外，全部由代理类来完成。
- 装饰是增强，是辅助，目标仍然可以自行对外提供服务，装饰器只起增强作用。



